<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pong wars | Koen van Gilst</title>
    <meta
      name="description"
      content="The eternal battle between day and night, good and bad. Written in JavaScript with some HTML & CSS in one index.html. Feel free to reuse the code and create your own version."
    />
    <link rel="canonical" href="https://pong-wars.koenvangilst.nl/" />
    <link rel="author" href="https://koenvangilst.nl" />
    <meta name="theme-color" content="#172B36" />
    <meta name="creator" content="Koen van Gilst" />
    <script
      defer
      data-domain="pong-wars.koenvangilst.nl"
      src="https://plausible.koenvangilst.nl/js/script.js"
    ></script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
        background: #202020;
        color: #f5f5f5;
        font-family: monospace;
      }

      /* zwei Hälften nebeneinander */
      #container {
        display: flex;
        width: min(1200px, 100vw);
        height: min(800px, 100vh);
      }

      #left,
      #right {
        flex: 1;
        display: flex;
        flex-direction: column;
      }

      /* Spielfeld-Hälfte: Inhalt zentrieren */
      #left {
        align-items: center;
        justify-content: center;
        padding: 10px;
      }

      #pongCanvas {
        display: block;
        border-radius: 4px;
        overflow: hidden;
        width: 100%;
        height: auto;
        max-width: 600px;
        max-height: 600px;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);
      }

      #score {
        margin-top: 8px;
        font-size: 14px;
      }

      #made {
        margin-top: 4px;
        font-size: 10px;
      }

      #made a {
        color: #d9e8e3;
      }

      /* rechte Hälfte: zwei Plot-Blöcke übereinander */
      #right {
        padding: 10px 10px 10px 20px;
        gap: 20px;
        justify-content: space-between;
      }

      .chartBlock {
        flex: 0 0 48%;
        display: flex;
        flex-direction: column;
      }

      .chartTitle {
        font-size: 11px;
        margin-bottom: 4px;
        padding-left: 4px;
        color: #d9e8e3;
      }

      .chartCanvas {
        background: #111;
        border-radius: 4px;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        width: 100%;
      }
    </style>
  </head>

  <body>
    <div id="container">
      <!-- linke Hälfte: Spielfeld -->
      <div id="left">
        <canvas id="pongCanvas" width="600" height="600"></canvas>
        <div id="score"></div>
        <p id="made">
          made by
          <a href="https://koenvangilst.nl/labs/pong-wars">Koen van Gilst</a> | source on
          <a href="https://github.com/vnglst/pong-wars">github</a>
        </p>
      </div>

      <!-- rechte Hälfte: Plots -->
      <div id="right">
        <div class="chartBlock">
          <div class="chartTitle">Live-Anteil Day / Night</div>
          <canvas
            id="ratioChart"
            class="chartCanvas"
            width="400"
            height="220"
          ></canvas>
        </div>
        <div class="chartBlock">
          <div class="chartTitle">Histogramm der Anteile</div>
          <canvas
            id="histChart"
            class="chartCanvas"
            width="400"
            height="220"
          ></canvas>
        </div>
      </div>
    </div>
  </body>

  <script>
    // ========= Original-Pong-Wars-Logik =========

    const colorPalette = {
      ArcticPowder: "#F1F6F4",
      MysticMint: "#D9E8E3",
      Forsythia: "#FFC801",
      DeepSaffron: "#FF9932",
      NocturnalExpedition: "#114C5A",
      OceanicNoir: "#172B36",
    };

    const canvas = document.getElementById("pongCanvas");
    const ctx = canvas.getContext("2d");
    const scoreElement = document.getElementById("score");

    const DAY_COLOR = colorPalette.MysticMint;
    const DAY_BALL_COLOR = colorPalette.NocturnalExpedition;
    const NIGHT_COLOR = colorPalette.NocturnalExpedition;
    const NIGHT_BALL_COLOR = colorPalette.MysticMint;
    const SQUARE_SIZE = 25;
    const MIN_SPEED = 5;
    const MAX_SPEED = 10;

    const numSquaresX = canvas.width / SQUARE_SIZE;
    const numSquaresY = canvas.height / SQUARE_SIZE;

    let dayScore = 0;
    let nightScore = 0;

    const squares = [];

    // Fläche initial befüllen
    for (let i = 0; i < numSquaresX; i++) {
      squares[i] = [];
      for (let j = 0; j < numSquaresY; j++) {
        squares[i][j] = i < numSquaresX / 2 ? DAY_COLOR : NIGHT_COLOR;
      }
    }

    const balls = [
      {
        x: canvas.width / 4,
        y: canvas.height / 2,
        dx: 8,
        dy: -8,
        reverseColor: DAY_COLOR,
        ballColor: DAY_BALL_COLOR,
      },
      {
        x: (canvas.width / 4) * 3,
        y: canvas.height / 2,
        dx: -8,
        dy: 8,
        reverseColor: NIGHT_COLOR,
        ballColor: NIGHT_BALL_COLOR,
      },
    ];

    let iteration = 0;

    function drawBall(ball) {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, SQUARE_SIZE / 2, 0, Math.PI * 2, false);
      ctx.fillStyle = ball.ballColor;
      ctx.fill();
      ctx.closePath();
    }

    function drawSquares() {
      dayScore = 0;
      nightScore = 0;

      for (let i = 0; i < numSquaresX; i++) {
        for (let j = 0; j < numSquaresY; j++) {
          ctx.fillStyle = squares[i][j];
          ctx.fillRect(i * SQUARE_SIZE, j * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);

          if (squares[i][j] === DAY_COLOR) dayScore++;
          if (squares[i][j] === NIGHT_COLOR) nightScore++;
        }
      }
    }

    function checkSquareCollision(ball) {
      for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
        const checkX = ball.x + Math.cos(angle) * (SQUARE_SIZE / 2);
        const checkY = ball.y + Math.sin(angle) * (SQUARE_SIZE / 2);

        const i = Math.floor(checkX / SQUARE_SIZE);
        const j = Math.floor(checkY / SQUARE_SIZE);

        if (i >= 0 && i < numSquaresX && j >= 0 && j < numSquaresY) {
          if (squares[i][j] !== ball.reverseColor) {
            squares[i][j] = ball.reverseColor;

            if (Math.abs(Math.cos(angle)) > Math.abs(Math.sin(angle))) {
              ball.dx = -ball.dx;
            } else {
              ball.dy = -ball.dy;
            }
          }
        }
      }
    }

    function checkBoundaryCollision(ball) {
      if (
        ball.x + ball.dx > canvas.width - SQUARE_SIZE / 2 ||
        ball.x + ball.dx < SQUARE_SIZE / 2
      ) {
        ball.dx = -ball.dx;
      }
      if (
        ball.y + ball.dy > canvas.height - SQUARE_SIZE / 2 ||
        ball.y + ball.dy < SQUARE_SIZE / 2
      ) {
        ball.dy = -ball.dy;
      }
    }

    function addRandomness(ball) {
      ball.dx += Math.random() * 0.02 - 0.01;
      ball.dy += Math.random() * 0.02 - 0.01;

      ball.dx = Math.min(Math.max(ball.dx, -MAX_SPEED), MAX_SPEED);
      ball.dy = Math.min(Math.max(ball.dy, -MAX_SPEED), MAX_SPEED);

      if (Math.abs(ball.dx) < MIN_SPEED) ball.dx = ball.dx > 0 ? MIN_SPEED : -MIN_SPEED;
      if (Math.abs(ball.dy) < MIN_SPEED) ball.dy = ball.dy > 0 ? MIN_SPEED : -MIN_SPEED;
    }

    // ========= Statistik / Charts =========

    const totalSquares = numSquaresX * numSquaresY;
    const ratioCtx = document.getElementById("ratioChart").getContext("2d");
    const histCtx = document.getElementById("histChart").getContext("2d");

    const maxPoints = 600;
    const bins = 20;

    const histCountsDay = new Array(bins).fill(0);
    const histCountsNight = new Array(bins).fill(0);

    const ratioChart = new Chart(ratioCtx, {
      type: "line",
      data: {
        labels: [],
        datasets: [
          {
            label: "Day",
            data: [],
            borderColor: DAY_COLOR,
            borderWidth: 2,
            pointRadius: 0,
            tension: 0,
          },
          {
            label: "Night",
            data: [],
            borderColor: NIGHT_COLOR,
            borderWidth: 2,
            pointRadius: 0,
            tension: 0,
          },
        ],
      },
      options: {
        animation: false,
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            ticks: { display: false },
            grid: { display: false },
          },
          y: {
            min: 0,
            max: 1,
            grid: { color: "#333" },
          },
        },
        plugins: {
          legend: {
            labels: { color: "#d9e8e3" },
          },
        },
      },
    });

    const histLabels = Array.from({ length: bins }, (_, i) =>
      ((i + 0.5) / bins).toFixed(2)
    );

    const histChart = new Chart(histCtx, {
      type: "line",
      data: {
        labels: histLabels,
        datasets: [
          {
            label: "Day",
            data: histCountsDay,
            borderColor: DAY_COLOR,
            borderWidth: 2,
            pointRadius: 0,
            tension: 0.2,
            fill: false,
          },
          {
            label: "Night",
            data: histCountsNight,
            borderColor: NIGHT_COLOR,
            borderWidth: 2,
            pointRadius: 0,
            tension: 0.2,
            fill: false,
          },
        ],
      },
      options: {
        animation: false,
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            title: { display: true, text: "Anteil" },
            grid: { color: "#333" },
            ticks: { color: "#d9e8e3" },
          },
          y: {
            beginAtZero: true,
            grid: { color: "#333" },
            ticks: { color: "#d9e8e3" },
          },
        },
        plugins: {
          legend: {
            labels: { color: "#d9e8e3" },
          },
        },
      },
    });

    function updateCharts() {
      const ratioNight = nightScore / totalSquares;
      const ratioDay = 1 - ratioNight;

      ratioChart.data.labels.push("");
      ratioChart.data.datasets[0].data.push(ratioDay);
      ratioChart.data.datasets[1].data.push(ratioNight);

      if (ratioChart.data.labels.length > maxPoints) {
        ratioChart.data.labels.shift();
        ratioChart.data.datasets[0].data.shift();
        ratioChart.data.datasets[1].data.shift();
      }
      ratioChart.update("none");

      let idxNight = Math.floor(ratioNight * bins);
      let idxDay = Math.floor(ratioDay * bins);
      if (idxNight < 0) idxNight = 0;
      if (idxNight >= bins) idxNight = bins - 1;
      if (idxDay < 0) idxDay = 0;
      if (idxDay >= bins) idxDay = bins - 1;

      histCountsNight[idxNight]++;
      histCountsDay[idxDay]++;

      histChart.data.datasets[0].data = histCountsDay;
      histChart.data.datasets[1].data = histCountsNight;
      histChart.update("none");
    }

    // ========= Haupt-Loop =========

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawSquares();

      scoreElement.textContent = `day ${dayScore} | night ${nightScore}`;

      balls.forEach((ball) => {
        drawBall(ball);
        checkSquareCollision(ball);
        checkBoundaryCollision(ball);
        ball.x += ball.dx;
        ball.y += ball.dy;
        addRandomness(ball);
      });

      // Charts seltener updaten, um Performance zu schonen
      if (iteration % 5 === 0) {
        updateCharts();
      }

      iteration++;
    }

    const FRAME_RATE = 100;
    setInterval(draw, 1000 / FRAME_RATE);
  </script>
</html>
