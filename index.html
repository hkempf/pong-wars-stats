<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pong wars | Koen van Gilst</title>
    <meta
      name="description"
      content="The eternal battle between day and night, good and bad. Written in JavaScript with some HTML & CSS in one index.html. Feel free to reuse the code and create your own version."
    />
    <link rel="canonical" href="https://pong-wars.koenvangilst.nl/" />
    <link rel="author" href="https://koenvangilst.nl" />
    <meta name="theme-color" content="#172B36" />
    <meta name="creator" content="Koen van Gilst" />
    <script
      defer
      data-domain="pong-wars.koenvangilst.nl"
      src="https://plausible.koenvangilst.nl/js/script.js"
    ></script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
        background: #202020;
        color: #f5f5f5;
        font-family: monospace;
      }

      /* Zwei Hälften nebeneinander */
      #container {
        display: flex;
        width: min(1400px, 100vw);
        height: min(800px, 100vh);
      }

      #left,
      #right {
        flex: 1;
        display: flex;
        flex-direction: column;
      }

      /* Linke Hälfte: Spielfeld mittig, Infos unten */
      #left {
        padding: 10px;
      }

      #leftInner {
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between;
      }

      #pongCanvas {
        display: block;
        border-radius: 4px;
        overflow: hidden;
        width: 100%;
        height: auto;
        max-width: 600px;
        max-height: 600px;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);
      }

      #infoRow {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 8px;
        font-size: 14px;
      }

      #made {
        margin-top: 4px;
        font-size: 10px;
      }

      #made a {
        color: #d9e8e3;
      }

      #pauseBtn {
        padding: 2px 10px;
        font-size: 12px;
        border-radius: 4px;
        border: 1px solid #555;
        background: #303030;
        color: #f5f5f5;
        cursor: pointer;
      }

      #pauseBtn:hover {
        background: #404040;
      }

      /* Rechte Hälfte: zwei Plot-Blöcke, bündig zu Spielfläche
         280px + 40px + 280px ≈ 600px Höhe */
      #right {
        padding: 10px 10px 10px 20px;
      }

      #rightInner {
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
      }

      .chartBlock {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .chartTitle {
        font-size: 11px;
        margin-bottom: 4px;
        color: #d9e8e3;
      }

      .chartCanvas {
        background: #111;
        border-radius: 4px;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        max-width: 100%;
      }
    </style>
  </head>

  <body>
    <div id="container">
      <!-- Linke Hälfte -->
      <div id="left">
        <div id="leftInner">
          <canvas id="pongCanvas" width="600" height="600"></canvas>

          <div>
            <div id="infoRow">
              <div id="score"></div>
              <button id="pauseBtn">Pause</button>
            </div>

            <p id="made">
              made by
              <a href="https://koenvangilst.nl/labs/pong-wars">Koen van Gilst</a> | source on
              <a href="https://github.com/vnglst/pong-wars">github</a>
            </p>
          </div>
        </div>
      </div>

      <!-- Rechte Hälfte -->
      <div id="right">
        <div id="rightInner">
          <div class="chartBlock">
            <div class="chartTitle">
              Live-Anteil Day / Night (geglättet, inkl. Min/Max)
            </div>
            <canvas
              id="ratioChart"
              class="chartCanvas"
              width="600"
              height="280"
            ></canvas>
          </div>
          <div class="chartBlock">
            <div class="chartTitle">
              Histogramm der Anteile (normalisiert)
            </div>
            <canvas
              id="histChart"
              class="chartCanvas"
              width="600"
              height="280"
            ></canvas>
          </div>
        </div>
      </div>
    </div>
  </body>

  <script>
    // ========= Farbpalette & Konstanten =========

    const colorPalette = {
      ArcticPowder: "#F1F6F4",
      MysticMint: "#D9E8E3",
      Forsythia: "#FFC801",
      DeepSaffron: "#FF9932",
      NocturnalExpedition: "#114C5A",
      OceanicNoir: "#172B36",
    };

    const canvas = document.getElementById("pongCanvas");
    const ctx = canvas.getContext("2d");
    const scoreElement = document.getElementById("score");
    const pauseBtn = document.getElementById("pauseBtn");

    const DAY_COLOR = colorPalette.MysticMint;
    const DAY_BALL_COLOR = colorPalette.NocturnalExpedition;
    const NIGHT_COLOR = colorPalette.NocturnalExpedition;
    const NIGHT_BALL_COLOR = colorPalette.MysticMint;
    const SQUARE_SIZE = 25;
    const MIN_SPEED = 5;
    const MAX_SPEED = 10;

    const numSquaresX = canvas.width / SQUARE_SIZE;
    const numSquaresY = canvas.height / SQUARE_SIZE;

    let dayScore = 0;
    let nightScore = 0;

    const squares = [];
    const prevSquares = [];
    const prev2Squares = [];

    function copySquares(from, to) {
      for (let i = 0; i < numSquaresX; i++) {
        for (let j = 0; j < numSquaresY; j++) {
          to[i][j] = from[i][j];
        }
      }
    }

    // Fläche initial befüllen
    for (let i = 0; i < numSquaresX; i++) {
      squares[i] = [];
      prevSquares[i] = [];
      prev2Squares[i] = [];
      for (let j = 0; j < numSquaresY; j++) {
        const col = i < numSquaresX / 2 ? DAY_COLOR : NIGHT_COLOR;
        squares[i][j] = col;
        prevSquares[i][j] = col;
        prev2Squares[i][j] = col;
      }
    }

    const balls = [
      {
        x: canvas.width / 4,
        y: canvas.height / 2,
        dx: 8,
        dy: -8,
        reverseColor: DAY_COLOR,
        ballColor: DAY_BALL_COLOR,
      },
      {
        x: (canvas.width / 4) * 3,
        y: canvas.height / 2,
        dx: -8,
        dy: 8,
        reverseColor: NIGHT_COLOR,
        ballColor: NIGHT_BALL_COLOR,
      },
    ];

    let iteration = 0;
    let paused = false;

    // Stuck-Erkennung
    let lastChangeIteration = 0;
    const STALE_KICK_THRESHOLD = 20000;
    const STALE_RESET_THRESHOLD = 200000;

    pauseBtn.addEventListener("click", () => {
      paused = !paused;
      pauseBtn.textContent = paused ? "Play" : "Pause";
    });

    function drawBall(ball) {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, SQUARE_SIZE / 2, 0, Math.PI * 2, false);
      ctx.fillStyle = ball.ballColor;
      ctx.fill();
      ctx.closePath();
    }

    function drawSquares() {
      dayScore = 0;
      nightScore = 0;

      for (let i = 0; i < numSquaresX; i++) {
        for (let j = 0; j < numSquaresY; j++) {
          ctx.fillStyle = squares[i][j];
          ctx.fillRect(i * SQUARE_SIZE, j * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);

          if (squares[i][j] === DAY_COLOR) dayScore++;
          if (squares[i][j] === NIGHT_COLOR) nightScore++;
        }
      }
    }

    function checkSquareCollision(ball) {
      let changed = false;

      for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
        const checkX = ball.x + Math.cos(angle) * (SQUARE_SIZE / 2);
        const checkY = ball.y + Math.sin(angle) * (SQUARE_SIZE / 2);

        const i = Math.floor(checkX / SQUARE_SIZE);
        const j = Math.floor(checkY / SQUARE_SIZE);

        if (i >= 0 && i < numSquaresX && j >= 0 && j < numSquaresY) {
          const current = squares[i][j];
          const target = ball.reverseColor;

          if (current !== target) {
            // A -> B -> A verhindern
            if (prev2Squares[i][j] === target) {
              continue;
            }

            squares[i][j] = target;
            changed = true;

            if (Math.abs(Math.cos(angle)) > Math.abs(Math.sin(angle))) {
              ball.dx = -ball.dx;
            } else {
              ball.dy = -ball.dy;
            }
          }
        }
      }

      if (changed) {
        lastChangeIteration = iteration;
      }
    }

    function checkBoundaryCollision(ball) {
      if (
        ball.x + ball.dx > canvas.width - SQUARE_SIZE / 2 ||
        ball.x + ball.dx < SQUARE_SIZE / 2
      ) {
        ball.dx = -ball.dx;
      }
      if (
        ball.y + ball.dy > canvas.height - SQUARE_SIZE / 2 ||
        ball.y + ball.dy < SQUARE_SIZE / 2
      ) {
        ball.dy = -ball.dy;
      }
    }

    function addRandomness(ball) {
      ball.dx += Math.random() * 0.02 - 0.01;
      ball.dy += Math.random() * 0.02 - 0.01;

      ball.dx = Math.min(Math.max(ball.dx, -MAX_SPEED), MAX_SPEED);
      ball.dy = Math.min(Math.max(ball.dy, -MAX_SPEED), MAX_SPEED);

      if (Math.abs(ball.dx) < MIN_SPEED) ball.dx = ball.dx > 0 ? MIN_SPEED : -MIN_SPEED;
      if (Math.abs(ball.dy) < MIN_SPEED) ball.dy = ball.dy > 0 ? MIN_SPEED : -MIN_SPEED;
    }

    function kickBalls() {
      balls.forEach((ball, idx) => {
        ball.x = canvas.width / 2 + (Math.random() - 0.5) * canvas.width * 0.4;
        ball.y = canvas.height / 2 + (Math.random() - 0.5) * canvas.height * 0.4;
        const speed = MIN_SPEED + Math.random() * (MAX_SPEED - MIN_SPEED);
        const angle = Math.random() * Math.PI * 2;
        ball.dx = Math.cos(angle) * speed * (idx === 0 ? 1 : -1);
        ball.dy = Math.sin(angle) * speed;
      });
      // lastChangeIteration hier bewusst NICHT setzen
    }

    function resetBoard() {
      for (let i = 0; i < numSquaresX; i++) {
        for (let j = 0; j < numSquaresY; j++) {
          const col = i < numSquaresX / 2 ? DAY_COLOR : NIGHT_COLOR;
          squares[i][j] = col;
          prevSquares[i][j] = col;
          prev2Squares[i][j] = col;
        }
      }

      balls[0].x = canvas.width / 4;
      balls[0].y = canvas.height / 2;
      balls[0].dx = 8;
      balls[0].dy = -8;

      balls[1].x = (canvas.width / 4) * 3;
      balls[1].y = canvas.height / 2;
      balls[1].dx = -8;
      balls[1].dy = 8;

      lastChangeIteration = iteration;
    }

    // ========= Statistik / Charts =========

    const totalSquares = numSquaresX * numSquaresY;
    const ratioCtx = document.getElementById("ratioChart").getContext("2d");
    const histCtx = document.getElementById("histChart").getContext("2d");

    const maxPoints = 600;
    const bins = 20;
    const binWidth = 1 / bins;
    const binCenters = Array.from(
      { length: bins },
      (_, i) => (i + 0.5) * binWidth
    );

    const histCountsDay = new Array(bins).fill(0);
    const histCountsNight = new Array(bins).fill(0);
    let totalSamples = 0;

    let smoothDay = 0.5;
    let smoothNight = 0.5;
    let maxDay = 0.5;
    let maxNight = 0.5;
    let minDay = 0.5;
    let minNight = 0.5;
    const alpha = 0.9; // Glättung

    const ratioChart = new Chart(ratioCtx, {
      type: "line",
      data: {
        labels: [],
        datasets: [
          {
            label: "Day (smooth)",
            data: [],
            borderColor: DAY_COLOR,
            borderWidth: 2,
            pointRadius: 0,
            tension: 0,
          },
          {
            label: "Night (smooth)",
            data: [],
            borderColor: NIGHT_COLOR,
            borderWidth: 2,
            pointRadius: 0,
            tension: 0,
          },
          {
            label: "Day max",
            data: [],
            borderColor: DAY_COLOR,
            borderWidth: 1,
            borderDash: [5, 5],
            pointRadius: 0,
            tension: 0,
          },
          {
            label: "Night max",
            data: [],
            borderColor: NIGHT_COLOR,
            borderWidth: 1,
            borderDash: [5, 5],
            pointRadius: 0,
            tension: 0,
          },
          {
            label: "Day min",
            data: [],
            borderColor: DAY_COLOR,
            borderWidth: 1,
            borderDash: [2, 4],
            pointRadius: 0,
            tension: 0,
          },
          {
            label: "Night min",
            data: [],
            borderColor: NIGHT_COLOR,
            borderWidth: 1,
            borderDash: [2, 4],
            pointRadius: 0,
            tension: 0,
          },
        ],
      },
      options: {
        animation: false,
        responsive: false,
        scales: {
          x: {
            ticks: { display: false },
            grid: { display: false },
          },
          y: {
            min: 0,
            max: 1,
            grid: { color: "#333" },
          },
        },
        plugins: {
          legend: {
            labels: { color: "#d9e8e3" },
          },
        },
      },
    });

    const midlinePlugin = {
      id: "midline",
      afterDraw(chart) {
        const xScale = chart.scales.x;
        const yScale = chart.scales.y;
        const xValue = 0.5;
        if (xValue < xScale.min || xValue > xScale.max) return;
        const xPixel = xScale.getPixelForValue(xValue);
        const ctx = chart.ctx;
        ctx.save();
        ctx.strokeStyle = "#666";
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(xPixel, yScale.top);
        ctx.lineTo(xPixel, yScale.bottom);
        ctx.stroke();
        ctx.restore();
      },
    };

    const histChart = new Chart(histCtx, {
      type: "line",
      plugins: [midlinePlugin],
      data: {
        datasets: [
          {
            label: "Day",
            data: binCenters.map((x) => ({ x, y: 0 })),
            borderColor: DAY_COLOR,
            borderWidth: 2,
            pointRadius: 0,
            tension: 0.2,
            fill: false,
          },
          {
            label: "Night",
            data: binCenters.map((x) => ({ x, y: 0 })),
            borderColor: NIGHT_COLOR,
            borderWidth: 2,
            pointRadius: 0,
            tension: 0.2,
            fill: false,
          },
          {
            label: "Combined",
            data: binCenters.map((x) => ({ x, y: 0 })),
            borderColor: "#cccccc",
            borderWidth: 1,
            pointRadius: 0,
            tension: 0.2,
            fill: false,
          },
        ],
      },
      options: {
        animation: false,
        responsive: false,
        scales: {
          x: {
            type: "linear",
            min: 0,
            max: 1,
            title: { display: true, text: "Anteil" },
            ticks: { color: "#d9e8e3" },
            grid: { color: "#333" },
          },
          y: {
            min: 0,
            max: 1,
            grid: { color: "#333" },
            ticks: { color: "#d9e8e3" },
          },
        },
        plugins: {
          legend: {
            labels: { color: "#d9e8e3" },
          },
        },
      },
    });

    function updateCharts() {
      const ratioNight = nightScore / totalSquares;
      const ratioDay = 1 - ratioNight;

      totalSamples++;

      if (totalSamples === 1) {
        smoothDay = ratioDay;
        smoothNight = ratioNight;
        maxDay = smoothDay;
        maxNight = smoothNight;
        minDay = smoothDay;
        minNight = smoothNight;
      } else {
        smoothDay = alpha * smoothDay + (1 - alpha) * ratioDay;
        smoothNight = alpha * smoothNight + (1 - alpha) * ratioNight;

        if (smoothDay > maxDay) maxDay = smoothDay;
        if (smoothNight > maxNight) maxNight = smoothNight;
        if (smoothDay < minDay) minDay = smoothDay;
        if (smoothNight < minNight) minNight = smoothNight;
      }

      ratioChart.data.labels.push("");
      ratioChart.data.datasets[0].data.push(smoothDay);
      ratioChart.data.datasets[1].data.push(smoothNight);
      ratioChart.data.datasets[2].data.push(maxDay);
      ratioChart.data.datasets[3].data.push(maxNight);
      ratioChart.data.datasets[4].data.push(minDay);
      ratioChart.data.datasets[5].data.push(minNight);

      if (ratioChart.data.labels.length > maxPoints) {
        ratioChart.data.labels.shift();
        ratioChart.data.datasets.forEach((ds) => ds.data.shift());
      }
      ratioChart.update("none");

      let idxNight = Math.floor(ratioNight * bins);
      let idxDay = Math.floor(ratioDay * bins);
      if (idxNight < 0) idxNight = 0;
      if (idxNight >= bins) idxNight = bins - 1;
      if (idxDay < 0) idxDay = 0;
      if (idxDay >= bins) idxDay = bins - 1;

      histCountsNight[idxNight]++;
      histCountsDay[idxDay]++;

      const densNight = histCountsNight.map((c) => c / totalSamples);
      const densDay = histCountsDay.map((c) => c / totalSamples);
      const densCombined = densDay.map((v, i) => (v + densNight[i]) / 2);

      histChart.data.datasets[0].data = binCenters.map((x, i) => ({
        x,
        y: densDay[i],
      }));
      histChart.data.datasets[1].data = binCenters.map((x, i) => ({
        x,
        y: densNight[i],
      }));
      histChart.data.datasets[2].data = binCenters.map((x, i) => ({
        x,
        y: densCombined[i],
      }));

      histChart.update("none");
    }

    // ========= Haupt-Loop =========

    const FRAME_RATE = 100;

    function draw() {
      if (paused) return;

      // Historie aktualisieren (t-2 <- t-1 <- t)
      copySquares(prevSquares, prev2Squares);
      copySquares(squares, prevSquares);

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawSquares();

      scoreElement.textContent = `day ${dayScore} | night ${nightScore} | iter ${iteration}`;

      balls.forEach((ball) => {
        drawBall(ball);
        checkSquareCollision(ball);
        checkBoundaryCollision(ball);
        ball.x += ball.dx;
        ball.y += ball.dy;
        addRandomness(ball);
      });

      if (iteration % 5 === 0) {
        updateCharts();
      }

      const sinceChange = iteration - lastChangeIteration;
      if (sinceChange > STALE_RESET_THRESHOLD) {
        resetBoard();
      } else if (sinceChange > STALE_KICK_THRESHOLD) {
        kickBalls();
      }

      iteration++;
    }

    setInterval(draw, 1000 / FRAME_RATE);
  </script>
</html>
